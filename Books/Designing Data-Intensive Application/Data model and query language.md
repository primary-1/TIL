# 데이터 베이스 사용사례를 통한 모델 및 언어 이야기

    공부하고 있는 데이터 베이스를 이해하려고 한다면, 데이터 베이스가 나온 계기 혹은 구현한 이유와 모델을 이해해야한다.

## 데이터 모델

    모델이란 단어는 형이나 본보기, 회화·조각·사진 등 제작 대상이 되는 인물을 지칭한다.
    데이터 모델은 데이터 베이스 형이나 본보기를 뜻한다.

데이터 모델은 소프트웨어 일부이다. 그러므로 데이터 모델은 작성 구조 및 문제 해결을 위한 접근법에 영향을 미친다.

대부분 애플리케이션은 계층 형식으로 데이터 모델을 쌓아 만든다. 밑으로 내려갈때마다 하위 데이터 모델 표현 방법을 고려해야한다.

- 애플리케이션 개발은 현실에 맞추어 객체, 데이터구조 그리고 데이터 구조를 다루는 API를 모델링한다.
- 데이터 구조 저장은 범용 데이터모델(JSON, XML 문서, 관계형 데이터베이스 테이블, 그래프 모델)로 표현한다.
- 데이터



복잡한 애플리케이션은 여러 계층들을 쌓아서 은폐하려고 한다.
다른 그룹 사용자들이 애플리케이션 계층 일부분을 사용하려고 할 때 구현에 불 필요하고 신경 쓰지 않아도 될 부분은 무시해야한다. 효율적으로 일할 수 있게 만들기 때문이다.

키보드를 사용하는 사용자들이 키보드 혹은 마우스 대한 원리 및 기판 회로에 대한 지식이 필요없이 다룰 수 있어야 한다.

데이터 모델들은 다양한 구현 방식이 존재하며, 각 모델은 사용 패턴이 있다. 데이터 모델에 따라 프로그램이 할 수 있는 일, 없는 일이 결정되므로 중요한 요소다.
문서관계형 모델은 다대일 관계는 쉽지만, JOIN 같은 다대다 동작은 몇몇 데이터 베이스만 지원하거나, 어떤 연산은 빠르고 느린다던지.

데이터 모델 하나를 익히는데도 많은 시간이 걸린다. 데이터 모델을 하나만 사용하고 내부 동작에 대한 걱정이 없는 소프트에어 작성은 그 자체로 충분히 어렵다.

범용 데이터 모델을 설명하겠다. 관계형 모델과 문서 모델, 그리고 그래프 기반 데이터 모델을 비교하겠다.

## 관계형 모델과 문서 모델

![관계형 모델과 문서모델을 한 눈에 알아 볼 수 있는 그림](http://static.couchbaseinc.hosting.ca.onehippo.com/images/server/3.x/20170420-170703/relational_vs_doc1.png)

_https://developer.couchbase.com/documentation/server/3.x/developer/dev-guide-3.0/compare-docs-vs-relational.html_

[가장 많이 쓰이는 데이터 모델은 관계형 모델을 기반으로 한 SQL이다.](https://db-engines.com/en/ranking)

데이터는 관계로 구성되고 각 관계는 순서 없는 [튜플](http://eastroot1590.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9A%A9%EC%96%B4-%ED%8A%9C%ED%94%8CTuple%EA%B3%BC-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8Attribute) 모음이다.

1970년 중반, 세상에서 모습을 들어낸 관계형 데이터 베이스는 이론 중심적이였다. 그래서 많은 사람들이 효율적으로 구현할 수 있는가에 대한 의문을 제기하였다.

하지만, 1980년대 중반 관계형 데이터 베이스 관리시스템과 SQL은 정규화된 구조로 데이터를 저장하고 질의할 필요가 있는 사람들 대부분이 선택하는 도구가 됐다.

관계형 데이터베이스 근원은 1960 ~ 70년대에 메인프레임 컴퓨터에서 수행된 비지니스 데이터 처리에 있다.

이 사용 사례는 보통 [트랜잭션 처리와 일괄처리로](https://stackoverflow.com/questions/31680259/what-is-the-difference-between-sql-batch-and-transaction-in-orientdb) 현재 관점에서는 일상적으로 수행되는 일이다.

다른 데이터베이스를 사용하는 애플리케이션 개발자는 데이터베이스의 내부 데이터 표현에 대하여 많은 고민을 해야 했다. 하지만 관계형 모델 목표는 API의 추상화다.

수년 동안 데이터 저장과 쿼리를 위해 많은 접근 방식이 경쟁하였다. 1970 ~ 80년대 초반에는 네트워크 모델과 계층 모델이 주요 대안이였지만, 결국 관계형 모델이 우위를 차지했다.

오늘날 볼 수 있는 대부분 서비스(온라인 게시물, 토론, 소셜 네트워크, 전자 상거래, 게임 SaaS 생산성 애플리케이션 등)는 관계형 데이터 베이스를 사용한다.

## NoSQL의 탄생

    2009년대에 오픈소스, 분산 환경, 비관계형 데이터 베이스가 웹 스타트업 커뮤니티를 넘어 빠르게 확산되었다.

확산 될 수 있었던 이유는 다음과 같다.

- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성 필요
- 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
- 관계형 모델에서 지원하지 않는 특수 질의 동작
- 관계형 스키마 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

# 객체 관계형 불일치

    오늘날의 대부분 프로그램은 객체지향 언어로 개발을 하는데, 이것을 관계 지향형 데이터 베이스로 바꾸려고 시도한다면 거추장스러운 전환 계층이 필요하다.
    이런 모델 사이 분리를 종종 임피던스 불일치 라고 부른다.

[액티브레코드](https://www.martinfowler.com/eaaCatalog/activeRecord.html)나 하이버네이트 같은 객체 관계형 매핑(ORM) 프레임 워크는 전환 계층에 필요한 사용구 코드(boilerplate code) 양을 줄이지만 두 모델 간 차이를 완벽히 숨길 수 없다.

이력서 같은 데이터 구조는 모든 내용을 갖추고 있는 **문서**라서 JSON표현에 매우 적합하다.

그래서 일부 개발자는 JSON 모델이 애플리케이션 코드와 저장 계층 간 임피던스 불일치를 줄인다고 생각한다.

JSON 표현은 다중 테이블 스키마보다 더 나은 지역성을 갖는다. 다중 테이블 스키마에서 프로필을 가져오려면 다중 질의나 다중 JOIN을 해야한다. 하지만 JSON 표현에서는 한 곳에 존재하여 질의 하나로 충분하다.

## 다대일과 다대다 관계

사용자 인터페이스에 지역과 업계를 입력할 수 있는 자유 텍스트 필드가 있다면 평문으로 저장하는 편이 합리적이지만 지리적 지역과 업계의 표준 목록으로 드롭다운 리스트나 자동 완성 기능을 만들어 사용자가 선택하게 하는 데는 다음과 같은 장점이 있다.

- 프로필 간 일관된 스타일과 철자
- 모호함 회피
    - 이름이 여러개인 도시 혹은 기업이 있는 경우
- 갱신의 편의성
    - 정치적 사건으로 도시 이름이 변경되는 경우
- 현지화 지원
    - 다른 언어로 번역할 때 표준 목록을 현지화해 사이트를 보는 사람의 언어로 변환이 가능하다.
- 더 나은 검색

ID나 텍스트 문자열 저장 여부는 중복의 문제다, ID를 사용하는 경우 사람에게 의미 있는 정보는 한 곳에만 저장하고 그것을 참조하는 모든 것은 ID를 사용한다.

텍스트를 직접 저장한다면 그것을 사용하는 모든 레코드에서 사람을 의미하는 정보를 중복해서 저장하게 된다.

ID를 사용하게 된다면 ID 자체는 아무 의미가 없기 때문에 변경할 필요가 없으며, 식별 정보를 변경해도 ID는 동일하게 유지할 수 있다.

하지만 의미를 가지는 경우라면 미래에 언젠가는 ID를 변경해야 할 수도 있다. 만약에 정보가 중복되어 있다면 해당 항목을 변경해야 하는데 이것은 쓰기 오버헤드와 불일치 위험이 존재한다.

중복을 제거하는 일이 데이터베이스 정규화 이면에 놓인 핵심 개념이다.

중복된 데이터를 정규화하려면 다대일 관계가(많은 사람들은 한 특정 지역에 살고 많은 사람들은 한 특정 업계에서 일한다) 필요한데 안타깝게도 다대일 관계는
관계형 데이터 베이스(쉬운 문서 결합, 다른 테이블 로우를 참조하는 방식)에서는 쉽지만 문서 모델에(약한 지원) 적합하지 않다.

데이터 베이스 자체가 조인을 지원하지 않는다면 데이터베이스에 대한 다중 질의를 만들어서 애플리케이션 코드에서 조인을 흉내 내야 한다.

더욱이 애플리케이션 초기 버전이 조인 없는 문서 모델에 적합하더라도 애플리케이션에 기능을 추가하면서 데이터는 점차 상호 연결되는 경향이 있다.

## 문서 데이터베이스는 역사를 반복하고 있나?

관계형 DB에서는 일상적으로 다대다 관계를 유지하며 join 을 사용한다. 문서 데이터베이스와 NoSQL은 데이터베이스에서 다대다 관계를 표현하는 제일 좋은 방법에 대한 논쟁을 다시 열었다.
이 논쟁은 NoSQL보다 훨씬 오래됐으며 초기 전상화 데이터베이스 시스템으로 돌아간다.

IBM 정보 관리 시스템 IMS는 계층 모델이라고 불리고 간단한 데이터 모델로 사용중이다. 그리고 놀랍게도 계층 모델은 JSON 모델과 비슷하며, 데이터를 중첩된 레코드 트리로 표현한다.

일대다 관계에서는 잘 동작하지만, Join을 사용하는 다대 다 관계 표현은 어려워 개발자는 데이터를 중복하지 한 레코드와 다른 레코드의 참조를 수동으로 해야할지 결정해야 하였다.

## 네트워크 모델

    하나의 공통적인 부모가 있다면 그 밑에 연결된 수많은 자식들로 이루어진 트리 구조
    각 레코드가 여러 부모와 자식을 가질 수 있게 함으로써 일반화된 그래프 구조를 이룬다.

네트워크에서 필요한 데이터 접근방법은 최상위 레코드로부터 연속된 연결을 따라가는데 끝에서 끝까지 본다.

만약, 레코드가 다중 부모를 가진다면 애플리케이션 코드는 다양한 관계를 모두 추적해야 한다. 코다실 위원회도 이 방식이 n차원 데이터 공간을 항해하는 것과 같다고 인정했다.

수동 접근 경로 선택은 하드웨어 성능이 낮은 환경에서 호율적으로 사용할 수 있었다. 그렇지만 데이터 베이스 질의와 갱신을 위한 코드가 매우 복잡하고 유연하지 못한 문제가 있었다.

계층 모델과 네트워크 모델 모두, 원하는 데이터가 경로에 없다면 어려운 상황에 놓인다. 접근 경로를 변경할 수 있지만 아주 많은 수작업 데이터베이스 질의 코드를 살펴봐야 하고 새로운 접근 경로를 다루기 위해 재작성해야 한다.

네트워크 모델을 사용하는 애플리케이션은 데이터를 바꾸려고 시도하는 작업은 매우 어려운 일이었다.

## 관계형 모델

대조적으로 관계형 모델은 알려진 모든 데이터를 배치한다. 관계는 튜플 컬렉션이 전부다. 얽히고설킨 중첩 구조와 데이터를 보고 싶을 때 따라가야 할 복잡한 접근 경로가 없다.

임의 접근과 일치하는 테이블 일부 또는 모든 로우를 선택하여 읽을 수 있다. 일부 칼럼을 키로 지정해 칼럼과 일치하는 특정 로우를 읽을 수 있다.

다른 테이블과 외래 키 관계에 대해 신경쓰지 않는다. 임의 테이블에 새 로우를 삽입할 수 있다.

### 질의 최적화기 (Query Optimizer)

    관계형 데이터 베이스는 사용자가 요청한 질의를 직접적으로 수정한다.
    질의일부를 어떤 순서로 실행할지를 결정한다. 결정 내용으로 사용할 색인을 결정한다.

최적화 한 것은 **"접근 경로"** 된다. 접근 경로를 애플리케이션 개발자가 만들지 않는다. 질의 최적화기가 만든다. 접근 경로를 고려할 필요가 없다.

새로운 방식으로 데이터에 질의하고 싶다. 그렇다면 색인을 선언한다. 질의 최적화기는 가장 적합한 색인을 사용한다.
