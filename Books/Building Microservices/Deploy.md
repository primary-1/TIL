배포
==============

    최종 사용자에게 소프트웨어를 전달하는 과정을 배포라고 한다.
    모놀리식 애플리케이션의 배포는 간단하지만, 상호 의존성을 중시하는 마이크로서비스의 배포와는 전혀 다르다.

CI
---

    지속적 통합(Continuous Intergration)은 퀄리티 컨트롤을 적용하는 프로세스를 실행시키는 것이다.
    개발 관점에서 보면, 지속적으로 작성해온 코드베이스를 합쳐 서비스에 올리는 것이다.

### CI가 필요한 이유

    CI를 하지 않는다면 다음과 같은 문제 상황이 발생한다.

1. 다른사람과 동기를(서비스의 코드) 맞추지 않아, 완전히 서로 다르거나 혹은 이미 구현한 컴포넌트등 침해할 수 있음

2. 지속적으로 하지 않는다면, 릴리즈 주기가 매우 길어져 사용자들에게 서비스를 보여주지 못하는 상황이 발생

3. 배포하는데 도구 혹은 절차가 존재하지 않는다면 릴리즈 하는데도 비용과 시간이 많이 든다.

[위와 같이 혼돈의 상황을 Hell이라고 부르는걸 좋아하는 서양 문화 답게 통합의 지옥이라고 부른다.](http://c2.com/cgi/wiki?IntegrationHell)

```CI를 한다면 이런 이점을 얻을 수 있다.```

1. 코드 품질에 대한 빠른 피드백을 얻을 수 있다.

2. 산출물의 빌드를 위한 모든 코드는 버전 관리되므로 언제든지 다시 만들 수 있다.

3. CI 도구 자체의 기능에 따라 어떤 테스트를 하였는지 확인 할 수 있다.


### CI의 동작방식

    코드베이스에서 주 브런치에 Commit이 된다면, 해당 커밋에 대한 테스트와 각가지 단계를 파이프라인으로 다루어 배포를 한다.

#### 파이프라인?

    파이프라인(Pipe Line)이라는 용어는 많이 사용되는데, 개발에서의 파이프라인 혹은 단계에서의 파이프라인 등등 사용되는데,
    이 전 단계의 결과 값을 다음 작업으로 넘겨주는것을 파이프라인이라고 한다.

> Ex) 프라미스 체인도 파이프라인이다.
```
Promise(() => pseudoAsync()).then(...).then(...).then(...)
```

### 빌드 파이프 라인 동작 과정

    일반적인 빌드 파이프 라인 동작 과정은 이와 같다.

> 컴파일과 빠른 테스트(유닛 테스트) -> 느린 테스트(통합 테스트) -> UAT(사용자 인수 테스트) -> 성능 테스트 -> 실환경 배포

**서비스는 모든 다양한 환경에서 동일해야 한다.**

#### UAT 사용자 인수 테스트

    시스템이 실제 운영 환경에서 준비가 되었는지 최종적으로 확인하는 단계

사용자가 테스트를 해서 잘못된 점이나 이해가 상충되는 부분을 확인, 테스트 하는 절차이다.

### CI 도구와 CI는 다르다.

    위와 같은 도구들을 사용한다고 해서 CI를 실천한다고 할 수 있을까?
    제즈 험블의 3가지로 CI를 사용하고 있는건지 CI 도구만 사용하는 건지 알 수 있다.

##### 1. 하루에 한 번 메인 브랜치에 체크인하는가?

    여러분의 코드는 물론, 다른 사람들이 변경한 코드 또한 자주 확인하지 않는다면 통합이 더 어려워 진다.
    변경을 위해 단기 브랜치를 사용하여도 메인 브랜치에 통합해라.

##### 2. 변경을 확인할 테스트 집합이 있는가?

    테스트를 하지 않는다면 통합해서 작동하는지 구문상으로만 알 수 있으며, 시스템의 동작을 중단시키는 것 까지는 알 수 없다.
    코드가 기재한 댜로 동작하는지 검증하지 않는 CI는 CI가 아니다.

##### 3. 빌드가 깨졌을 때 팀이 그것을 최우선으로 하는가?

    녹색 빌드는 변경한 것이 안전하게 통합되었고, 적색 빌드는 마지막 변경이 통합되지 않았음을 의미한다.

빌드 문제의 해결과 관련 없는 추가적인 체크인을 중단해야 한다.


모놀리식 서비스는 큰 통합 서비스, 마이크로서비스는 분활 통합 서비스???
---------------------------------------------------

    기존 모놀리식 서비스는 충돌만 고려하면서 서비스를 운영만 하였으면 됬었다.
    하지만, 마이크로서비스는 모든 서비스를 고려하면서 배포해야 한다, 좋은 방법이 있을까?

몇 가지 방법이 있는데, 가장 단순한 방법은 하나로 엮는것이다.

지속적으로 통합하는 서버를 만들어서, 커밋이 있을 때 마다 해당 소스코드를 모두다 가져와 빌드 하는 것이다.

이것을 락스텝 릴리즈라고 한다.

```
Object 예제
CI_BUILD_LIST
[
    { Name: A, Source: 1, Version: 1.3 },
    { Name: B, Source: 2, Version: 1.3 },
    { Name: C, Source: 3, Version: 1.3 }
]

위에 예제의 Source가 숫자로 나타낸다고 하자, 만약에 B의 소스가 업데이트 되어 4로 됬다면 해당 빌드는 이렇게 변한다.

CI_BUILD_LIST
[
    { Name: A, Source: 1, Version: 2.4 },
    { Name: B, Source: 4, Version: 2.4 },
    { Name: C, Source: 3, Version: 2.4 }
]

이렇게 된다면, 한 서비스의 일부분만 바꿔도 모두다 빌드한다는 단점이 있다.
```

테스트할 필요가 없는 것까지 테스트하므로 실제로 필요 이상의 시간이 소요될 수 있다.

> 이것은 하나의 변경을 개발에서 실운영환경에 전달하는 속도, 즉 순환 시간에 영향을 준다.

이런 방법을 개선하기 위해, CI 빌드가 한가지의 서비스만 빌드 하도록 하면 된다.

```
Object 예제

USER-SERVICE-BUILD = { Name: USER, Source: 1, Version 0.1 }
CATALOG-SERVICE-BUILD = { Name: CATALOG, Source: 2, Version 0.3 }
Invoice-SERVICE-BUILD = { Name: INVOICE, Source: 3, Version 0.2 }

이런식으로 단일 산출물을 만들 수 있다, 그래서 앞서 말한 한 서비스의 일부분 업데이트여도

USER-SERVICE-BUILD = { Name: USER, Source: 3023, Version 4.9 }
CATALOG-SERVICE-BUILD = { Name: CATALOG, Source: 2, Version 0.3 }
Invoice-SERVICE-BUILD = { Name: INVOICE, Source: 3, Version 0.2 }

이렇게, 한 가지 서비스만 수행하고 배포할 산출물만 얻는다.
```

#### 아이를 반으로 나누거라

    우리가 원하는 필요없는 과정도 생략하고, 서로 다른 빌드를 가질 수 있어 관리하기도 편해졌다.
    근데, 그렇다면 소스 코드 저장소 혹은 이 세세한 서비스들의 관리자는 어떻게 선택할 수 있는가?
    누군가 솔로몬이 되어 이 문제를 해결해야 하는가??

간단하다! 각각 코드를 통합한 것으로 가져온 것이 아닌 하나의 코드저장소를 가지게 만들면 된다!

### 지속적 배포(Continuous Delivery)

    지속적 배포는 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고,
    나아가 모든 체크인을 빠짐없이 릴리즈 후보로 여기는 접근 방법이다.

CD를 완벽히 지원하는 도구는 소프트웨어의 실환경에 이르는 전체 경로를 모델링하면서 파이프라인들을 정의하고 시각화한다.

소프트웨어의 생산 경로 전체를 모델링함으로써 소프트웨어 품질의 가시성을 크게 향상시키고 개선할 주요 사안인 빌드 및 리리즈 프로세스를 한 곳에서 볼 수 있으므로 릴리즈 간 소요 시간을 크게 줄일 수 있다.

### 앞서 말한 빌드당 서비스가 만병 통치약일까?

    팀이 새로운 프로젝트, 아무것도 없는 무에서 유를 만들 때
    서비스 경계를 확정하는 동안 도메인 개념이 있을 때 까지는 서비스를 큰 부분으로 유지하는 것이 좋다.

이 확정하는 동안, 거의 혼돈의 상태로 서비스가 안팍에 있던게 매일매일 바뀌고 달라지므로, 하나의 빌드로 포함시키는 것이 좋다.

플랫폼별 산출물
-----------------

    대부분의 기술스택들은 서로 다른 확장자를 가지고 있다.
    자바에는 JAR, 루비는 GEM, 파이썬은 Egg .. 등등

하지만 마이크로서비스 관점에서는 기술 스택에 따라 산출물 자체만으로 부족할 수 있다.

자바의 JAR파일을 실행시킨다면 프로세스 매니저를 사용하나등 산출물을 배포하고 실행하기 위해 다른 소프트웨어를 설치하고 구성할 방법도 필요하다.

이러한 산출물들이 특정 기술에 스택에 한정되어 있을 때 생각해보자.

루비 gem, JAR 파일, Node.js , npm 패키지 등 전혀 다른 배포 메커니즘을 사용한다면, 그 기술을 테스트 하려는 사람 혹은 배포 관리자는 지옥을 맛 볼 것이다.

자동화는 하부 산출물의 배포 메커니즘의 차이를 감추는 데 크게 도움이 된다.

운영 체제 산출물
------------------

    특정 기술에 제한적인 산출물과 관련된 문제를 해결할 수 있는 방법은 간단하다.
    운영 체제 네이티브한(Windows MSI, Redhat Linux RPM, Ubuntu deb) 산출물을 생성하면 된다.

이렇게 운영 체제 산출물을 사용한다면, 하부 기술에 대한 것을 신경 쓸 필요 없고 해당 패키지의 도구만 사용하면 된다.

하지만, 이런 방법으로 한다면 굉장히 어려움을 겪거나 단점이 존재한다.

1. FPM으로(리눅스) 패키지리를 만드는 것은 쉽지만, MSI 및 나머지는 만들기가 까다롭다.

2. 다른 운영 체제에 배포를 할 때. 다른 운영체제에서 산출물을 관리하는 일은 부담스러운 일이다.

서버 설치하는데만 30년
----------------------

    자바 애플리케이션 배포를 위해 서버를 프로비저닝 하자고 하였을 때,
    오라클 VM을 설치하는데, 5분 머신이 프로비저닝 되는데 2~3분, JVM을 설치하는데 3분.
    그리고 드디어 우리가 원하는 소프트웨어를 설치 할 수 있다.

소프트웨어는 통계를 위한 콜렉트디, 로그를 위한 로그스태쉬, 모니터링을 위한 나기오스를 적절히 설치...

시간이 지날수록 소프트웨어 설치할 것이 많아지고, 의존성을 가진 것들을 또 프로비저닝 하자면.. 서버 설치만 하다가 끝날 것이다.

물론 퍼펫, 셰프, 앤서블, 그리고 이들의 부류는 이미 설치된 소프트웨어를 재설치하지 않겠지만, 이것을 또 확인하는 작업도 시간이 걸리므로 언제나 빠른 것은 아니다.

그리고, 해당 머신들을 가까이 두면 환경불일치(임의로 설치한 것들로 인해 구성의 차이가 발생하는 것)를 초래하여 피하고자 한다.

주문형 컴퓨팅 플랫폼을 사용하고 있다면 하루단위로 새로운 인스턴스를 계속 끄고 켤 수 있다. (주문형 컴퓨팅은 유저를 위해서 컴퓨터 자원들을 사용할 수 있게 만드는 배달모델이다)

### 기동시간 줄이기
    계속 될수록 제대로 소프트웨어가 설치 혹은 환경이 구성되어있는지 확인하는것은 지겹다
    만약 하루에도 여러 번 확인하려 한다면 빠른 피드백을 제공하는 측면에서는 실제로 문제가 될 수 있다.

소프트웨어를 설치하기 전에 모든 필수 구성 요소(Provisioning Task, OS, JVM, library) 설치 할 때 까지 제로-다운타임을 허용하지 않는다면 **실환경에 배포 시 다운타임이 늘어날 수 있다.**
이 기동시간을 줄이는 방법은 공통적으로 의존하는 것들을 주입한 **가상 머신 이미지를** 만드는 것이다.

결국에는 설치하는 시간만 들테고 소프트웨어를 찾고 설치하고 깔고.. 하는 시간이 많이 드는 작업들이 사라지기 때문에 **시간을 상당히 줄여준다.**

그래도 세상엔 완벽한 것은 없다고 몇 가지 단점이 존재한다.

#### 커스텀 이미지의 단점

1. 이미지의 생성 시간이 오래 걸릴 수 있다.
    - 배포용 바이너리 설치하는데 30분, 1시간, 1시간 30분.. 그 이상이 걸린다면 다른 배포 방법을 찾는게 더 빠를지도 모른다.

2. 생성된 이미지가 클 수 있다.
    - 로그도 넣고, 내부 DB도 넣고, 또 다른 의존성을 챙기고 만들어진 이미지가 매우 크다면.. 네트워크를 통해 쉬운일이 아닐지도 모른다.</br>그래서, 이런 단점을 보완한 컨테이너 기술이 있다.

그리고, 이것도 여러가지 플랫폼이 있기 때문에(VMWare, AWS, 베이그런트, 랙스페이스 등등..) 머신 환경 구성을 위해 사용되는 다른 도구들과 호환되지 않는다.

### 커스텀 서비스 이미지

    의존성만 커스텀 이미지로 만들라는 규칙과 규정은 없다, 그렇다면 서비스도 이미지로 만든다면 어떻게 될까?

실제 넷플릭스도 빠른 가동 시간으로 인해 자신들의 서비스를 AWS AMI로 생성하는 모델을 채택하였다.

결과적으로 따져보면 *기술 스택이 어쩌고..어떤 기술(JAR 혹은 GEM)으로 돌려야 한다.* 라는 것을 신경 쓸 필요 없이

서비스의 동작 유/무만 보면 되는 거니까 배포하는 데 초점을 둘 수 있고, 또 다른 배포 개념인 **불변 서버를** 구현하는데 좋은 방법이다

### 불변 서버

    모든 환경 구성을 소스 관리 시스템에 저장함으로써 서비스뿐만 아니라 전체 환경까지 자동적으로 복제하려 노력한다.
    그러나 우리가 배포 프로세스를 실행하고 나서 누군가 머신에서 소스 관리 시스템에 있는 것과는 별개로 변경한다면 어떻게 될까?

전에 말했던 **환경 구성 불일치**라고 알려진 문제로, 소스 관리 시스템의 코드가 실행 중인 호스트의 환경 구성에 더 이상 반영되지 않는 상태를 말한다.

#### 문제를 피하는 방법

간단하다, **건들지 않으면 된다.** 아주 아주 작은 코드 한 줄이여도 **새로운 머신을 생성하기 위해서는 빌드 파이프라인을 통해야 한다.**

이미지 기반의 배포 방식을 사용하지 않더라도 이 패턴을 구현할 수 있지만, 산출물이든 다른 서비스를 이와 같이 사용하는 방식의 논리적 확장이다.</br>
*이미지 기반 배포방식 X 이 패턴을 사용하는 것은, 산출물이든 다른 서비스를 이와 같이 행동하는 똑같은 방식의 논리적 확장이다.*

이 패턴은 하나의 변경을 개발에서 실운영환경에 전달하는 속도인 **순환 시간**에 대해 동일한 유의 사항이 적용된다.

그리고, 머신에 사용되는 모든 데이터가 다른 곳에도 저장되는 것을 보장해야한다.

> 정말 엄청 복잡한 방식이지만, 그에 따른 직관적인 배포와 추론하기 쉬운 환경을 이끌어 낸다.

환경
--------

    전에 말했듯이, 서비스가 배포 되기 전에는 CD의 파이프라인을 완전히 통과 해야한다.
    그러면 느린 테스트, UAT, 성능, 실운영 환경들을 고려해야 할 것이다!

각각의 환경마다 적어도 분리되고 구별되는 환경 구성과 호스트가 있지만 더 다양할 것이다.

실운영 환경 테스트에서는 분산된 서버로 구성되있을 수도 있지만, 실운영은 하나의 서버로만 동작 할 수 있다!

그렇게 되면 환경의 차이가 발생하고, 몇 가지 문제를 불러올 수 있다.

*문제가 필자가 겪었던 입장으로 적혀져 있어, 후에 추상화해서 추가할 예정*


서비스 환경 구성
----------------

    서비스는 몇 가지 환경 구성을 필요로 한다, 이상적으로 환경 구성은 작아야 하며,
    '데이터 베이스에 접속 하기 위해 어떤 계정을 사용해야 하는가?' 와 같이 변경해야 하는 제한된 기능이 될 것이다.

환경 구성이 본질적인 서비스 행위를 더 많이 침해할수록 환경 구성은 환경마다 더 달라지고 특정 환경에서 발생되는 문제도 더 많아진다. 정말 끔찍한 일이다.

> 그러므로, 환경 구성은 전적으로 최소화되어야 한다.

서비스의 환경마다 바뀌어야 할 몇 가지 환경 구성을 가지고 있다면 배포 프로세스의 일부로서 어떻게 다루어야 할까?

### 하나의 환경당 산출물을 빌드한 후, 환경 구성을 산출물에 포함시키는 방법

    환경 구성이 빌드되어 산출물에 포함되므로 배포하기만 하면 모든 것이 잘 동작해야 한다.

하지만, 이것은 문제가 될 수 있다

산출물들을 빌드하기 위해서는 또 추가적인 시간이 소요된다.

빌드 시간에 어떤 환경이 존재해야하는지 알아야하고, 민감한 환경 구성 데이터(비밀번호, 토큰 등등..)을 어떻게 다룰 것인지.

### 환경마다 가지고 있는 환경 구성들
    더 나은 방법은 단일 산출물을 생성하여 환경 구성을 분리해서 관리하는 것이다.

각 환경에 속성 파일 또는 설치 프로세스에 전달될 다른 매개 변수와 같은 것이 될 수있다.

EX) TEST환경에는 TEST 전용 DB의 정보, 실운영 환경에서는 항상 복제하고 관리하는 DB의 정보..



