모노리식 서비스 분리하기
=========================

    모놀로식은 마이크로서비스와 달리 강한 결합성, 낮은 응집력을 가지고 있는건 잘 알고 있다.
    근데, 왜? 꼭 모놀리식을 마이크로서비스로 바꿔야 하는가?

모놀리식 서비스를 마이크로서비스로 바꾸었을 때의 장점
-----------------------------------------------------

1. 변경의 속도
    - 배포하는데 속도 제한이 걸리지 않는다.
2. 팀 분활
    - 한가지 모놀리식 서비스의 개발이 아닌 마이크로서비스 단위로 개발을 할 수 있다.
3. 기술의 이기종성
    - 한가지 언어로 구현되있는게 아닌 서비스에 맞는 언어를 선택해서 구현할 수 있다! (서비스 지향 아키텍쳐)
4. DB 분리
    - 이후 밑에서 다룰 예정이다.
5. 보안
    - 각 각의 서비스 마다 접근 할 수 있는 리소스가 다르니, 보안적 측면에서도 좋다.

> 사용하고 있는 비지니스에 위 장점들이 **필요하다고 판단한다면,** 마이크로서비스로 바꾸는것이 더 효율적이다.

모놀리식 서비스의 접합부
---------------------------

보통 접합부라고 생각을 한다면 코드베이스에서 각각의 서비스를 잇는 부분이라고 생각할 수 있는데

모놀리식 서비스의 접합부는 이 접합부를 지워도 나머지 모놀리식 서비스에서는 영향이 없는 부분이다.

> 그럼 가장 좋은 접합부를 추상적인 개념으로 묶는다면 어떤 기준이 좋을까?

앞서 배운 BC(Bounded Context)가 좋은 접합부라고 볼 수 있다. 아예 경계선으로 나눈 도메인들의 집합이니까.

공예
---------

모놀리식은 대리석 공예로 비교해도 손색없을 정도로 공예를 하면서 지켜야 할 원칙들이 비슷하다

목적을 비유해보면 이와 같이 성립할 수 있다.

> 큰 대리석(모놀리식)을 깍아서(분리) 조각상(마이크로서비스)로 만드는 것이니까.

또 이런 원칙도 같다.

> 한 번에 모든것을 깍으려고 하지 않고 (Big Bang, 점진적 접근법)
> 머리, 몸통, 다리 한 부위마다 (DB Schema, Packaging..)
> 하나씩 차근 차근 (CodeBase 수정 -> DB Separate..)

모놀리식 분리순서
=====================

    모놀리식 서비스를 마이크로서비스로 바꾸는 단위를 나누자면,
    코드베이스와 데이터베이스로 분리 순서가 나뉘어 진다.

코드베이스
----------

1. 콘텍스트 대표하는 패키지를 구성한다

2. 대표 패키지로 **접합부를 기준으로 한** 기존 코드를 이동시킨다.

3. 코드 이동 도중에 발생하는 의존성을 분석한 후 대응한다.

데이터베이스
----------

1. 데이터베이스에 읽고 쓰는 코드 부분을 나눔

2. 객체 혹은 데이터 구조를 매핑하기 쉽게 분활 분할

3. 데이터베이스 리팩토링

데이터베이스 분할 작업중 발생하는 문제점들
------------------------------------------

### 외부 키 관계

    외래키로 다른 DB를 접근한다면, 이 서비스는 어떻게 바꿀 수 있을까?

1. 외래키로 접근하는 해당 코드를 지운다.
2. 해당 정보를 가져올 수 있는 API를 만든다.

이렇게 API를 사용하여 서로 분리된 DB와 네트워크 호출로 데이터를 처리한다면, 우리가 원하는 느슨한 결합성을 기대할 수 있다.

### 공유 정적 데이터

    어떤 정적 테이블을(ex. 국가코드) 모든 서비스가 공유하여 높은 결합성을 초래하는 경우가 있다.
    그런 테이블은 다음과 같은 방법으로 분해를 한다.

1. Ctrl C+V
    - 정적 테이블을 사용하는 서비스 마다 따로 복제하여 붙여넣는다.
    </br>만약 테이블 중 하나에 데이터가 추가된다면 나머지 테이블도 추가하여야 하는 번거로움과 위험성(잊고 추가를 안했을 시에)이 일어난다.

2. 열거형 데이터화
    - 자바에서 사용하는 Enum 처럼, 코드에서 공유할 수 있는 정적 데이터로 존재하는 것이다.
    </br>데이터 테이블로 구현하는 것 보다는 쉬운 방법이지만, 데이터 일관성의 문제가 초래한다.

3. 공유 정적 데이터 서비스
    - 극단적으로, 데이터를 반환하는 서비스로 만드는 것이다.

### 공유 데이터
    재무 서비스와(결제, 환불 등등) 창고 서비스가(제품 발송, 수신) 있는데
    재무는 고객 테이블에 대한 접근을 하고 창고 서비스도 고객 테이블에 대한 접근을 한다고 했을 때
    고객는 분리되지 않는 데이터로 강한 결합성을 나타낸다.

도메인 개념으로 봤을 때, 고객 테이블은 고객 도메인으로 바꿀 수 있다.

고객 서비스로 만든 뒤 재무와 창고 서비스가 이용할 수 있도록 API를 만들면 우리가 원하는 느슨한 결합성으로 이루어진 서비스가 될 수 있다.

데이터 베이스 리팩토링
----------------------

    앞서 설명한 내용은 데이터 베이스를 분리할 때 발생하는 문제점이였다.
    이제 실제로 분리하는 방법에 대해 다루어 보자

### 단계적인 분리

    코드 베이스도 단계별로 분류를 하였는데, 데이터 베이스도 마찬가지로 단계별로 분류를 한다.

1. 스키마 분류
    - 각각의 애플리케이션으로 만들기 전에 서비스는 이전과 같이 하나로 유지한 채 스키마를 분류한다.

2. 애플리케이션을 서비스로 분리

하지만, 이렇게 스키마를 나눈 후 애플리케이션 코드를 나눌때 우리는 **트랜잭션에** 대해서 많은 고려를 해야한다.

트랜잭션의 경계
----------------

    트랜잭션을 보장하기 위해 트랜잭션의 경계를 설정해야하는데
    이 트랜잭션에 대해서 알아야 왜 트랜잭션을 사용해야 하는지 알아야만 한다.

### 트랜잭션

    우리가 ATM에서 돈을 뽑는다고 가정을 해보자.

먼저, ATM에서 출금 메뉴를 누르고 카드를 넣고 원하는 인출금액을 선택하고 돈과 카드를 가지고 나가면 된다.

그런데 만약에 인출 금액을 선택하고 인출하는 과정에서 *모종의 전산 오류로 돈은 나오지 않은채 거래 종료가 된다면?*

**고객 DB에는 정상적으로 돈이 인출됬다 판단하여 계좌 금액에서는 그 인출금액이 통장에서 빠져나갈 것이다.**

이 사태를 막기 위해 만들어진 것이 트랜잭션이다.

이벤트가 모두 발생하거나 전혀 발생하지 않게 해주는 것으로, 데이터베이스에 데이터를 입력할 때 매우 유용하며

잘못된 경우에는 모든 것을 롤백하여 데이터의 불일치 상태를 피할 수 있기 때문이다.

### 마이크로서비스의 트랜잭션 구현

    모놀리식 서비스는 스키마가 하나라, 모든 생성과 업데이트는 단일 트랜잭션 경계 내에서 수행되어 안정성 있지만
    분리되어 동작하는 마이크로서비스 같은 경우에는 서로 다른 스키마를 사용하여 트랜잭션의 안정성을 잃게되는데 트랜잭션을 보장 할 수 있는 방법이 있을까?

각각의 스키마에 접근하는 것에 트랜젝션을 걸었다고 가정해도 이와같은 상황이 발생할 수 있다.

> ATM에서 돈이 정상적으로 출금이 됬음 (성공한 이벤트)
> 모종의 전산 오류로 사용자의 정보에서 출금 이벤트가 발생하지 않아 돈이 그대로 남음 (실패한 이벤트)

이런 상황을 피할 수 있도록 몇 가지 방법이 존재한다

#### 나중에 재시도 하기

    출금이 됬다는 이벤트를 모아두어 재시도하기에 충분하다
    그래서 이런 연산을 큐나 혹은 로그파일에 큐잉하여 나중에 재시도 해도 된다.

[이것은 최종적 일관성의 또 다른 형태다.](https://en.wikipedia.org/wiki/Consistency_model)

**이런 접근 방식은 비즈니스 작업들이 오래 지속될 경우 특히 유용하다.**

#### 전체 작업 중지하기

    다른방안은 전체 작업을 중지하는 것이다.
    이런 경우 시스템을 다시 일관성이 유지된 상태로 복귀시켜야 한다.

보상 트랜잭션을 발행하여, 직전의 트랜젝션을 되돌릴 새로운 트랜잭션을 발생시키는 것이다.

사용자의 계좌정보에서 돈을 빼낼 수도 있고, 여러가지 방법으로 되돌린다면

작업이 실패한 이유와, 같은 작업으로 실패되지 안도록 기록하기 위해 **작업이 실패했다는 UI를 통해 리포트할 필요가 있다.**

여기서 몇 가지 떠오르는 질문이 있다. 이 보상 트랜잭션을 처리하는 로직의 위치는 어디이고, 이 보상 트랜잭션 또한 **실패한다면?**

보상 트랜잭션이 실패한다면, 보상 트랜잭션을 재시도하거나 백엔드 프로세스를 수행할 필요가 있다.

그런데, 이런 일관성이 유지되기 바라는 작업이 한두 개가 아니라 셋, 넷, 다섯... 생각만해도 끔찍하다.

각각의 실패 모드에 대해 보상 트랜잭션을 처리하는 것은 구현은 고사하고 이해하기도 어렵다.

#### 분산 트랜잭션

    보상 트랜잭션을 수동으로 통제하는 방식의 대안은 분산 트랜잭션의 사용이다.
    분산 트랜잭션은 하부 시스템에서 수행되는 다양한 트랜잭션을 통제하기 위해
    트랜잭션 관리자라는 전체적인 통제 프로세스를 사용해 트랜잭션 내부의 여러 트랜잭션을 확장하려고 시도함

분산 트랜잭션은 2단계 커밋을 사용하는데 구조로 표현하면 이렇게 표현할 수 있다.

```
Coordinator                             Cohort
                QUERY TO COMMIT
                --------------->
                  VOTE YES/NO           prepare*/abort*
                <---------------
commit*/abort*    COMMIT/ROLLBACK
                --------------->
                  ACKNOWLEDGMENT        commit*/abort*
                <---------------
end
```

이 단계에서 참여자(Cohort)는 로컬 트랜잭션의 진행 가능 여부를 트랜잭션 매니저에게 알린다.

만약 트랜잭션 매니저가 모든 참여자로부터 찬성표를 얻는다면 참여자에게 각자의 커밋을 수행하라고 지시한다.

**트랜잭션 매니저가 반대표를 하나라도 받는다면 모든 참여자에게 롤백 명령을 보낸다.**